---
layout: post
title:  Okhttp学习
date:   2016-04-20 21:23:54
category: "学习"
---

`OkHttp` 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，`OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。
`Okhttp`的`client`的工作也像其他`client`一样接受request，然后产生一个response。使用Okhttp时，如果原始的`request`缺失headers，Okhttp会添加headers，包括 `Content-Length`, `Transfer-Encoding`, `User-Agent`, `Host`, `Connection`, and `Content-Type`。总之，Okhttp会为你做很多的事情。

###简单的使用

####同步get请求

下载一个文件，打印他的头部，将body转换成string打印

```java
	private final OkHttpClient client = new OkHttpClient();
    public void run() throws Exception {
        Request request = new Request.Builder()
                .url("http://publicobject.com/helloworld.txt")
                .build();

        Response response = client.newCall(request).execute();
        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

        Headers responseHeaders = response.headers();
        for (int i = 0; i < responseHeaders.size(); i++) {
            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
        }

        System.out.println(response.body().string());
    }
```

在上面的代码中，可以看到我们使用了`response.body().string()`，不过官方建议说当response的body体大小超过1MB的时候将body转换成一个数据流，因为`string()`方法会把整个body体加载到内存里面。

####异步get请求

在一个工作线程中下载一个文件，当response返回时通过回调进行处理。

```java
	private final OkHttpClient client = new OkHttpClient();
	public void asynRun() {
    	Request request = new Request.Builder()
    			.url("http://publicobject.com/helloworld.txt")
    			.build();
    	client.newCall(request).enqueue(new Callback() {
			
			@Override
			public void onResponse(Call arg0, Response arg1) throws IOException {
				if(!arg1.isSuccessful()){
					System.out.println("Failure");
				}
				Headers responseHeaders = arg1.headers();
				for(int i = 0; i < responseHeaders.size(); i++){
					System.out.println(responseHeaders.name(i)+":"+responseHeaders.value(i));
				}
				System.out.println(arg1.body().string());
			}
			
			@Override
			public void onFailure(Call arg0, IOException arg1) {
				System.out.println("Failure");
				
			}
		});
		
	}
```
可以看到上面的代码，我们是通过enqueue来实现回调的。

####对Headers操作

传统情况下Headers像一个`Map<String, String>`，不过也可以有一对多的键值对`multimap`，如Vary。当我们要重写`request headers`，可以使用`header(name, value)`覆盖已经有的键，或者通过`addHeader(name, value)`添加一对多的键值对multimap。而我们要获取header时，可以使用`header(name)`获取单键值对或者多键值对的第一个值，使用`headers(name)`获取多键值对的所有值在一个list里面。如：

```java
	public void headerRun() throws Exception {
    	Request request = new Request.Builder()
	        .url("https://api.github.com/repos/square/okhttp/issues")
	        .header("User-Agent", "OkHttp Headers.java")
	        .addHeader("Accept", "application/json; q=0.5")
	        .addHeader("Accept", "application/vnd.github.v3+json")
	        .build();

	    System.out.println(request.headers("Accept"));
	    
	    Response response = client.newCall(request).execute();
	    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

	    System.out.println("Server: " + response.header("Server"));
	    System.out.println("Date: " + response.header("Date"));
	    System.out.println("Vary: " + response.headers("Vary"));
	}
```

####Post方式提交String

使用`http post`发送 `request body` 到服务器，下面的历史是发送一段`markdown`文本到服务器然后渲染成HTML。（）注意，因为 `request body` 整个都在内存中，所以使用这个方法时要避免大文件（一般大于1MB）的传送。

```java
	public void postStringRun() throws Exception {
    	MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");
    	  String postBody = ""
    	      + "Releases\n"
    	      + "--------\n"
    	      + "\n"
    	      + " * _1.0_ May 6, 2013\n"
    	      + " * _1.1_ June 15, 2013\n"
    	      + " * _1.2_ August 11, 2013\n";
    	  System.out.println(postBody);

    	  Request request = new Request.Builder()
    	      .url("https://api.github.com/markdown/raw")
    	      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
    	      .build();

    	  Response response = client.newCall(request).execute();
    	  if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

    	  System.out.println(response.body().string());
	}
```

类似上面的代理，我们还可以post 一个文件，将 `RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)` 换成 `RequestBody.create(MEDIA_TYPE_MARKDOWN, new File(README.md));`即可。

####post方式提交Stream

下面我们提交`request body`为一个数据流。下面我们使用的是`BufferedSink.outputStream()`获取的`OutputStream`来传送，也可以使用Okio的 `bufferedsink`。（将2~997的数质数分解）

```java
	public void postStreamRun() throws Exception {
    	MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");
        RequestBody requestBody = new RequestBody() {
          @Override 
          public MediaType contentType() {
        	  return MEDIA_TYPE_MARKDOWN;
          }

          @Override 
          public void writeTo(BufferedSink sink) throws IOException {
        	  sink.outputStream().write("Numbers\n".getBytes());
        	  sink.outputStream().write("-------\n".getBytes());
        	  for (int i = 2; i <= 997; i++) {
        		  sink.outputStream().write(String.format(" * %s = %s\n", i, factor(i)).getBytes());
        	  }
          }

          private String factor(int n) {
        	  for (int i = 2; i < n; i++) {
        		  int x = n / i;
        		  if (x * i == n) return factor(x) + " × " + i;
        	  }
        	  return Integer.toString(n);
          	}
        };

        Request request = new Request.Builder()
        		.url("https://api.github.com/markdown/raw")
        		.post(requestBody)
        		.build();

        Response response = client.newCall(request).execute();
        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

        System.out.println(response.body().string());
	}
```
####传入POST参数，提交表单

```java
	public void parameterRun() throws Exception{
    	RequestBody formBody = new FormBody.Builder()
    			.add("search", "yaoming")
    			.build();
    	
    	Request request = new Request.Builder()
    			.url("https://en.wikipedia.org/w/index.php")
    			.post(formBody)
    			.build();
    	
    	Response response = client.newCall(request).execute();
    	if(response.isSuccessful()){
    		System.out.println(response.body().string());
    	}
	}
```

####Post提交分块请求

`MultipartBody.Builder`可以构建高雅的请求体，和HTML文件上传的表单形式一致。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如`Content-Disposition`，另外，如果`Content-Length` 和 `Content-Type` 可d用的话，他们会被自动添加到请求头中。

```java
public void multipartRun() throws Exception {
      // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
    	String IMGUR_CLIENT_ID = "...";
    	MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
    	RequestBody requestBody = new MultipartBody.Builder()
          .setType(MultipartBody.FORM)
          .addFormDataPart("title", "Square Logo")
          .addFormDataPart("image", "logo-square.png",
              RequestBody.create(MEDIA_TYPE_PNG, new File("/Users/zhouchaoyuan/Documents/logo-square.png")))
          .build();

    	Request request = new Request.Builder()
          .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
          .url("https://api.imgur.com/3/image")
          .post(requestBody)
          .build();

    	Response response = client.newCall(request).execute();
    	if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

    	System.out.println(response.body().string());
    }
```

####通过Gson来解析一个JSON Response

```java
	public void GSONRun() throws Exception{
    	Gson gson = new Gson();
		Request request = new Request.Builder()
				.url("https://api.github.com/gists/c2a7c39532239ff261be")
				.build();
		Response response = client.newCall(request).execute();
		if(response.isSuccessful()){
			Gist gist = gson.fromJson(response.body().string(), Gist.class);
			for(Map.Entry<String, GistFile> entry : gist.files.entrySet()){
				System.out.println(entry.getKey());
				System.out.println(entry.getValue().content);
			}
		}
	}
    static class Gist{
    	Map<String,GistFile>files;
    }
    static class GistFile{
    	String content;
    }
```

####请求缓存

缓存是网络请求中使用广泛的一项技术，我们需要对请求过的数据进行缓存，当然了，Okhttp也是支持这项技术的，下面我们通过代码来验证Okhttp缓存的机制：

```java
public void Cacherun() throws Exception {
    	  int cacheSize = 10 * 1024 * 1024; // 10 MiB
    	  File file = new File(".");
          Cache cache = new Cache(file, cacheSize);
          OkHttpClient client = new OkHttpClient.Builder()
    	            .cache(cache)
    	            .build();
    	  Request request = new Request.Builder()
    			  .url("http://publicobject.com/helloworld.txt")
    			  .build();

    	  Response response1 = client.newCall(request).execute();
    	  if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);

    	  String response1Body = response1.body().string();
    	  System.out.println("Response 1 response:          " + response1);
    	  System.out.println("Response 1 cache response:    " + response1.cacheResponse());
    	  System.out.println("Response 1 network response:  " + response1.networkResponse());

    	  Response response2 = client.newCall(request).execute();
    	  if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);

    	  String response2Body = response2.body().string();
    	  System.out.println("Response 2 response:          " + response2);
    	  System.out.println("Response 2 cache response:    " + response2.cacheResponse());
    	  System.out.println("Response 2 network response:  " + response2.networkResponse());

    	  System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
	}
```

从输出可以很明显看到缓存机制的存在：

	Response 1 response:          Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}
	Response 1 cache response:    null
	Response 1 network response:  Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}
	Response 2 response:          Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}
	Response 2 cache response:    Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}
	Response 2 network response:  null
	Response 2 equals Response 1? true
	
当然在有些情况下，我们需要去请求最新的资源，这个时候就需要强制请求网络数据了，可以使用`request = request.newBuilder().cacheControl(CacheControl.FORCE_NETWORK).build();`刷新我们的request来达到目的。

####取消操作

Okhttp也提供了类似cancel请求的接口Call.cancel()，使用Call.cancel()可以立即停止掉一个正在执行的异步或同步的call。如果一个线程正在写请求或者读响应，将会引发IOException，实例如下：

```java
public void cancelRun() throws Exception {
		int delayTime = 1;//通过修改延迟时间可以看到是否被异常cancel
        Request request = new Request.Builder()
                .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
                .build();

        final long startNanos = System.nanoTime();
        final Call call = client.newCall(request);
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

        // Schedule a job to cancel the call in delayTime second.
        executor.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.printf("%d Canceling call.%n", (System.nanoTime() - startNanos));
                call.cancel();
                System.out.printf("%d Canceled call.%n", (System.nanoTime() - startNanos));
            }
        }, delayTime, TimeUnit.SECONDS);

        try {
            System.out.printf("%d Executing call.%n", (System.nanoTime() - startNanos));
            Response response = call.execute();
            System.out.printf("call is cancel:" + call.isCanceled() + "%n");
            System.out.printf("%d Call was expected to fail, but completed: %s%n",
                    (System.nanoTime() - startNanos), response);
        } catch (IOException e) {
            System.out.printf("%d Call failed as expected: %s%n",
                    (System.nanoTime() - startNanos), e);
        }
    }
```

####支持超时

Okhttp支持链接读写的超时设置，如下：

```java
	public void timeOutRun() throws Exception {
		OkHttpClient client = new OkHttpClient()
				.newBuilder()
				.connectTimeout(10, TimeUnit.SECONDS)
				.writeTimeout(10, TimeUnit.SECONDS)
				.readTimeout(30, TimeUnit.SECONDS)
				.build();
	    Request request = new Request.Builder()
	        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
	        .build();

	    Response response = client.newCall(request).execute();
	    System.out.println("Response completed: " + response);
	}
```

ps:我们需要重新配置client时（比如说代理配置，超时，缓存），只需要client.clone()然后配置就行了

####处理验证

OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，我们需要在Authenticator提供证书（credentials）。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。

```java
	private int responseCount(Response response) {
		int result = 1;
	    while ((response = response.priorResponse()) != null) {
	      result++;
	    }
	    return result;
	}
	public void authenticationRun() throws Exception {
		OkHttpClient client = new OkHttpClient.Builder()
					.authenticator(new Authenticator() {
					@Override 
					public Request authenticate(Route route, Response response) throws IOException {
		            System.out.println("Authenticating for response: " + response);
		            System.out.println("Challenges: " + response.challenges());
		            String credential = Credentials.basic("jesse", "password1");//编码请求头部
//		            if (credential.equals(response.request().header("Authorization"))) {
//		                return null;//已经验证失败过了，就不要重复验证了
//		            }
		            if (responseCount(response) >= 3) {
		                return null; // 请求大于等于三次放弃
		            }
		            return response.request().newBuilder()
		                .header("Authorization", credential)
		                .build();
					}
		        })
		        .build();
	    Request request = new Request.Builder()
	        .url("http://publicobject.com/secrets/hellosecret.txt")
	        .build();

	    Response response = client.newCall(request).execute();
	    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

	    System.out.println(response.body().string());
	}
```

参考连接：

http://square.github.io/okhttp/

http://square.github.io/okhttp/3.x/okhttp/

https://github.com/square/okhttp/wiki/Recipes

http://www.cnblogs.com/ziwuge/archive/2011/09/27/2193385.html


     